<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <title>Dither!</title>
    <link rel="stylesheet"
          href="https://unpkg.com/@rogieking/figui3@latest/components.css" />
    <link rel="stylesheet"
          href="/rog.ie.css">
    <script src="/rog.ie.web-components.js"
            type="module"></script>
    <script src="https://unpkg.com/@rogieking/figui3@latest/fig.js?"></script>
    <style>
        .dither-app {
            width: 100%;
            max-width: 50rem;
            padding: 1rem;
            display: flex;
            gap: 0rem;
            margin: 0 auto;

            fig-image {
                --image-size: 100% !important;
                margin: 0 0 1rem 0;
                image-rendering: pixelated;
            }
        }

        .controls {
            padding: 1rem;
            width: 100%;

            fig-field {
                width: 100%;
                padding-left: 0;
                padding-right: 0;

                label {
                    min-width: 5rem !important;
                }
            }
        }

        .images {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: flex-start;
        }

        .image-container {
            background: white;
            padding: 10px;
            border-radius: 8px;

            &.output {
                image-rendering: pixelated;
            }

            img {
                width: 300px;
                height: auto;
            }

            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .image-label {
            text-align: center;
            margin-bottom: 10px;
            font-weight: 500;
            color: #333;
        }

        .control-group.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <main class="full-width">
        <figure class="dither-app">

            <fig-image upload="true"
                       label="Change image"
                       aspect-ratio="auto"
                       src="http://127.0.0.1:5500/dither/charli.jpeg"
                       size="large">
            </fig-image>

            <div class="controls">
                <h1>Dither</h1>
                <fig-field direction="horizontal">
                    <label for="ditheringAlgorithm">Algorithm</label>
                    <fig-dropdown id="ditheringAlgorithm"
                                  value="atkinson">
                        <option value="atkinson">Atkinson</option>
                        <option value="floydSteinberg">Floyd-Steinberg</option>
                        <option value="sierra">Sierra</option>
                        <option value="burkes">Burkes</option>
                        <option value="blueNoise">Blue Noise</option>
                    </fig-dropdown>
                </fig-field>

                <fig-field direction="horizontal">
                    <label for="colorLevels">Color Levels</label>
                    <fig-slider id="colorLevels"
                                min="2"
                                max="16"
                                value="4"
                                variant="minimal"
                                step="1"
                                text="true"
                                style="flex: 1; max-width: 200px;">
                    </fig-slider>
                </fig-field>

                <fig-field direction="horizontal">
                    <label for="imageScale">Scale</label>
                    <fig-slider id="imageScale"
                                min="5"
                                max="50"
                                value="25"
                                variant="minimal"
                                step="1"
                                text="true"
                                style="flex: 1; max-width: 200px;">
                    </fig-slider>
                </fig-field>

                <fig-field direction="horizontal">
                    <label for="blackWhiteMode">Grayscale</label>
                    <fig-checkbox id="blackWhiteMode"></fig-checkbox>
                </fig-field>

                <fig-field direction="horizontal"
                           id="thresholdGroup">
                    <label for="threshold">Brightness</label>
                    <fig-slider id="threshold"
                                min="-100"
                                max="100"
                                value="0"
                                variant="minimal"
                                step="1"
                                text="true"
                                style="flex: 1; max-width: 200px;">
                    </fig-slider>
                </fig-field>

                <fig-field direction="horizontal">
                    <label for="contrast">Contrast</label>
                    <fig-slider id="contrast"
                                min="-100"
                                max="100"
                                value="0"
                                variant="minimal"
                                step="1"
                                text="true"
                                style="flex: 1; max-width: 200px;">
                    </fig-slider>
                </fig-field>

                <fig-field direction="horizontal">
                    <label for="invertColors">Invert</label>
                    <fig-checkbox id="invertColors"></fig-checkbox>
                </fig-field>
            </div>
            </div>


            <div class="images"></div>
        </figure>

        <script>
            // Atkinson dithering algorithm (CPU implementation)
            function atkinsonDither(imageData, colorLevels) {

                const startTime = performance.now();
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;
                console.log('atkinsonDither', imageData, colorLevels, width, height)

                const quantizeGamma = (value) => {
                    // Convert to linear space (inverse gamma)
                    const linear = Math.pow(value / 255, 2.2);
                    // Quantize in linear space
                    const level = Math.round(linear * (colorLevels - 1));
                    // Convert back to gamma space
                    return Math.pow(level / (colorLevels - 1), 1 / 2.2) * 255;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;

                        // Process each color channel
                        for (let c = 0; c < 3; c++) {
                            const oldValue = data[idx + c];
                            const newValue = quantizeGamma(oldValue);
                            const error = oldValue - newValue;

                            data[idx + c] = newValue;

                            // Distribute error using Atkinson pattern
                            const errorFraction = error / 8;

                            // Right pixel
                            if (x + 1 < width) {
                                data[idx + 4 + c] += errorFraction;
                            }

                            // Two pixels to the right
                            if (x + 2 < width) {
                                data[idx + 8 + c] += errorFraction;
                            }

                            // Below left
                            if (y + 1 < height && x - 1 >= 0) {
                                data[((y + 1) * width + (x - 1)) * 4 + c] += errorFraction;
                            }

                            // Below
                            if (y + 1 < height) {
                                data[((y + 1) * width + x) * 4 + c] += errorFraction;
                            }

                            // Below right
                            if (y + 1 < height && x + 1 < width) {
                                data[((y + 1) * width + (x + 1)) * 4 + c] += errorFraction;
                            }

                            // Two rows below
                            if (y + 2 < height) {
                                data[((y + 2) * width + x) * 4 + c] += errorFraction;
                            }
                        }
                    }
                }

                const endTime = performance.now();
                console.log(`Atkinson dithering took ${endTime - startTime}ms`);

                // Create new ImageData from the modified data
                return new ImageData(data, width, height);
            }

            // Floyd-Steinberg dithering algorithm
            function floydSteinbergDither(imageData, colorLevels) {
                const startTime = performance.now();
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                const quantizeGamma = (value) => {
                    const linear = Math.pow(value / 255, 2.2);
                    const level = Math.round(linear * (colorLevels - 1));
                    return Math.pow(level / (colorLevels - 1), 1 / 2.2) * 255;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;

                        for (let c = 0; c < 3; c++) {
                            const oldValue = data[idx + c];
                            const newValue = quantizeGamma(oldValue);
                            const error = oldValue - newValue;

                            data[idx + c] = newValue;

                            // Floyd-Steinberg error distribution
                            // Right pixel (7/16)
                            if (x + 1 < width) {
                                data[idx + 4 + c] += error * 7 / 16;
                            }

                            // Below left (-1, +1) (3/16)
                            if (y + 1 < height && x - 1 >= 0) {
                                data[((y + 1) * width + (x - 1)) * 4 + c] += error * 3 / 16;
                            }

                            // Below (0, +1) (5/16)
                            if (y + 1 < height) {
                                data[((y + 1) * width + x) * 4 + c] += error * 5 / 16;
                            }

                            // Below right (+1, +1) (1/16)
                            if (y + 1 < height && x + 1 < width) {
                                data[((y + 1) * width + (x + 1)) * 4 + c] += error * 1 / 16;
                            }
                        }
                    }
                }

                const endTime = performance.now();
                console.log(`Floyd-Steinberg dithering took ${endTime - startTime}ms`);
                return new ImageData(data, width, height);
            }

            // Sierra dithering algorithm
            function sierraDither(imageData, colorLevels) {
                const startTime = performance.now();
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                const quantizeGamma = (value) => {
                    const linear = Math.pow(value / 255, 2.2);
                    const level = Math.round(linear * (colorLevels - 1));
                    return Math.pow(level / (colorLevels - 1), 1 / 2.2) * 255;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;

                        for (let c = 0; c < 3; c++) {
                            const oldValue = data[idx + c];
                            const newValue = quantizeGamma(oldValue);
                            const error = oldValue - newValue;

                            data[idx + c] = newValue;

                            // Sierra error distribution (divider: 32)
                            // Row 0
                            if (x + 1 < width) {
                                data[idx + 4 + c] += error * 5 / 32;
                            }
                            if (x + 2 < width) {
                                data[idx + 8 + c] += error * 3 / 32;
                            }

                            // Row 1
                            if (y + 1 < height && x - 2 >= 0) {
                                data[((y + 1) * width + (x - 2)) * 4 + c] += error * 2 / 32;
                            }
                            if (y + 1 < height && x - 1 >= 0) {
                                data[((y + 1) * width + (x - 1)) * 4 + c] += error * 4 / 32;
                            }
                            if (y + 1 < height) {
                                data[((y + 1) * width + x) * 4 + c] += error * 5 / 32;
                            }
                            if (y + 1 < height && x + 1 < width) {
                                data[((y + 1) * width + (x + 1)) * 4 + c] += error * 4 / 32;
                            }
                            if (y + 1 < height && x + 2 < width) {
                                data[((y + 1) * width + (x + 2)) * 4 + c] += error * 2 / 32;
                            }

                            // Row 2
                            if (y + 2 < height && x - 1 >= 0) {
                                data[((y + 2) * width + (x - 1)) * 4 + c] += error * 2 / 32;
                            }
                            if (y + 2 < height) {
                                data[((y + 2) * width + x) * 4 + c] += error * 3 / 32;
                            }
                            if (y + 2 < height && x + 1 < width) {
                                data[((y + 2) * width + (x + 1)) * 4 + c] += error * 2 / 32;
                            }
                        }
                    }
                }

                const endTime = performance.now();
                console.log(`Sierra dithering took ${endTime - startTime}ms`);
                return new ImageData(data, width, height);
            }

            // Burkes dithering algorithm
            function burkesDither(imageData, colorLevels) {
                const startTime = performance.now();
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                const quantizeGamma = (value) => {
                    const linear = Math.pow(value / 255, 2.2);
                    const level = Math.round(linear * (colorLevels - 1));
                    return Math.pow(level / (colorLevels - 1), 1 / 2.2) * 255;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;

                        for (let c = 0; c < 3; c++) {
                            const oldValue = data[idx + c];
                            const newValue = quantizeGamma(oldValue);
                            const error = oldValue - newValue;

                            data[idx + c] = newValue;

                            // Burkes error distribution (divider: 32)
                            // Row 0
                            if (x + 1 < width) {
                                data[idx + 4 + c] += error * 8 / 32;
                            }
                            if (x + 2 < width) {
                                data[idx + 8 + c] += error * 4 / 32;
                            }

                            // Row 1
                            if (y + 1 < height && x - 2 >= 0) {
                                data[((y + 1) * width + (x - 2)) * 4 + c] += error * 2 / 32;
                            }
                            if (y + 1 < height && x - 1 >= 0) {
                                data[((y + 1) * width + (x - 1)) * 4 + c] += error * 4 / 32;
                            }
                            if (y + 1 < height) {
                                data[((y + 1) * width + x) * 4 + c] += error * 8 / 32;
                            }
                            if (y + 1 < height && x + 1 < width) {
                                data[((y + 1) * width + (x + 1)) * 4 + c] += error * 4 / 32;
                            }
                            if (y + 1 < height && x + 2 < width) {
                                data[((y + 1) * width + (x + 2)) * 4 + c] += error * 2 / 32;
                            }
                        }
                    }
                }

                const endTime = performance.now();
                console.log(`Burkes dithering took ${endTime - startTime}ms`);
                return new ImageData(data, width, height);
            }

            // Blue noise dithering algorithm
            function blueNoiseDither(imageData, colorLevels) {
                const startTime = performance.now();
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                // Generate blue noise pattern (simple approximation)
                const noiseSize = 64;
                const noisePattern = new Array(noiseSize * noiseSize);
                for (let i = 0; i < noisePattern.length; i++) {
                    // Simple blue noise approximation using modulated random
                    const x = i % noiseSize;
                    const y = Math.floor(i / noiseSize);
                    noisePattern[i] = (Math.sin(x * 0.1) * Math.cos(y * 0.1) + 1) * 0.5;
                }

                const quantizeGamma = (value) => {
                    const linear = Math.pow(value / 255, 2.2);
                    const level = Math.round(linear * (colorLevels - 1));
                    return Math.pow(level / (colorLevels - 1), 1 / 2.2) * 255;
                };

                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;

                        // Get noise value
                        const noiseX = x % noiseSize;
                        const noiseY = y % noiseSize;
                        const noise = noisePattern[noiseY * noiseSize + noiseX];
                        const threshold = (noise - 0.5) * 50; // Adjust noise strength

                        for (let c = 0; c < 3; c++) {
                            const oldValue = data[idx + c] + threshold;
                            const newValue = quantizeGamma(Math.max(0, Math.min(255, oldValue)));
                            data[idx + c] = newValue;
                        }
                    }
                }

                const endTime = performance.now();
                console.log(`Blue noise dithering took ${endTime - startTime}ms`);
                return new ImageData(data, width, height);
            }

            // Global variables to store canvas and image data
            let canvas, ctx, originalImageData, ditheredImage;
            let width, height;

            // Function to resize images based on scale
            async function resizeImages() {
                if (!img || !img.complete) return;

                const scale = parseFloat(document.getElementById('imageScale').value);
                console.log('resize image', scale);
                width = img.naturalWidth;
                height = img.naturalHeight;


                // Recreate canvas with new dimensions
                canvas = new OffscreenCanvas(width * (scale / 100), height * (scale / 100));
                ctx = canvas.getContext('2d');

                // Draw the image onto the canvas with new dimensions
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // Store new original image data
                originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Reapply dithering with current settings
                const colorLevels = parseInt(document.getElementById('colorLevels').value);
                const brightnessAdjust = parseInt(document.getElementById('threshold').value);
                const contrastAdjust = parseInt(document.getElementById('contrast').value);
                const isGrayscale = document.getElementById('blackWhiteMode').checked;
                const isInverted = document.getElementById('invertColors').checked;

                await applyDithering(colorLevels, brightnessAdjust, contrastAdjust, isGrayscale, isInverted);
            }

            // Convert image to grayscale with brightness adjustment
            function applyGrayscaleWithBrightness(imageData, brightnessAdjust) {
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                for (let i = 0; i < data.length; i += 4) {
                    // Convert to grayscale using luminance formula
                    const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];

                    // Apply brightness adjustment (-100 to +100)
                    const adjustedGray = Math.max(0, Math.min(255, gray + brightnessAdjust));

                    // Set RGB to the same grayscale value
                    data[i] = adjustedGray;     // R
                    data[i + 1] = adjustedGray; // G
                    data[i + 2] = adjustedGray; // B
                    // Alpha stays the same
                }

                return new ImageData(data, width, height);
            }

            // Invert colors in the image
            function applyColorInversion(imageData) {
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                for (let i = 0; i < data.length; i += 4) {
                    // Invert RGB channels
                    data[i] = 255 - data[i];         // R
                    data[i + 1] = 255 - data[i + 1]; // G
                    data[i + 2] = 255 - data[i + 2]; // B
                    // Alpha stays the same
                }

                return new ImageData(data, width, height);
            }

            // Apply contrast adjustment to the image
            function applyContrastAdjustment(imageData, contrastAdjust) {
                const data = new Uint8ClampedArray(imageData.data);
                const width = imageData.width;
                const height = imageData.height;

                // Convert -100 to +100 range to contrast factor (0.5 to 2.0)
                const contrastFactor = contrastAdjust >= 0
                    ? 1 + (contrastAdjust / 100) * 1.0  // 0 to +100 -> 1.0 to 2.0
                    : 1 + (contrastAdjust / 100) * 0.5; // -100 to 0 -> 0.5 to 1.0

                for (let i = 0; i < data.length; i += 4) {
                    // Apply contrast to RGB channels
                    for (let c = 0; c < 3; c++) {
                        // Center around 128 (middle gray), apply contrast, then add back
                        const adjusted = (data[i + c] - 128) * contrastFactor + 128;
                        data[i + c] = Math.max(0, Math.min(255, adjusted));
                    }
                    // Alpha stays the same
                }

                return new ImageData(data, width, height);
            }

            async function applyDithering(colorLevels, brightnessAdjust = 0, contrastAdjust = 0, isGrayscale = false, isInverted = false) {
                if (!originalImageData) return;

                // Clear the canvas and redraw the original image
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // Get fresh image data
                let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Apply color inversion if enabled (first)
                if (isInverted) {
                    imageData = applyColorInversion(imageData);
                }

                // Apply contrast adjustment (second)
                if (contrastAdjust !== 0) {
                    imageData = applyContrastAdjustment(imageData, contrastAdjust);
                }

                // Apply grayscale conversion with brightness adjustment if enabled (third)
                if (isGrayscale) {
                    imageData = applyGrayscaleWithBrightness(imageData, brightnessAdjust);
                }

                // Get selected dithering algorithm
                const algorithm = document.getElementById('ditheringAlgorithm').value;

                // Apply selected dithering algorithm
                let ditheredData;
                switch (algorithm) {
                    case 'floydSteinberg':
                        ditheredData = floydSteinbergDither(imageData, colorLevels);
                        break;
                    case 'sierra':
                        ditheredData = sierraDither(imageData, colorLevels);
                        break;
                    case 'burkes':
                        ditheredData = burkesDither(imageData, colorLevels);
                        break;
                    case 'blueNoise':
                        ditheredData = blueNoiseDither(imageData, colorLevels);
                        break;
                    case 'atkinson':
                    default:
                        ditheredData = atkinsonDither(imageData, colorLevels);
                        break;
                }

                // Put the dithered data back onto the canvas
                ctx.putImageData(ditheredData, 0, 0);

                // Update the dithered image
                if (ditheredImage) {
                    try {
                        const blob = await canvas.convertToBlob();
                        const objectURL = URL.createObjectURL(blob);
                        const chit = ditheredImage.querySelector('fig-chit');
                        const oldSrc = chit.style.getPropertyValue('--src');

                        // Clean up previous object URL to prevent memory leaks
                        if (oldSrc && oldSrc.startsWith('blob:')) {
                            URL.revokeObjectURL(oldSrc);
                        }
                        chit.style.setProperty('--src', `url(${objectURL})`);
                    } catch (error) {
                        console.error('Error converting canvas to blob:', error);
                    }
                }
            }

            let img = new Image();

            function loadImageFromFigImage() {
                const figImage = document.querySelector('fig-image');
                const imageSrc = figImage?.getAttribute('src');

                if (imageSrc) {
                    img.src = imageSrc;
                }
            }

            img.onload = async () => {
                if (img) {
                    const scale = parseFloat(document.getElementById('imageScale').value);
                    width = img.naturalWidth;
                    height = img.naturalHeight;

                    const imagesContainer = document.querySelector('.images');

                    // Clear existing containers
                    imagesContainer.innerHTML = '';

                    // Create an offscreen canvas to extract image data
                    canvas = new OffscreenCanvas(width * (scale / 100), height * (scale / 100));
                    ctx = canvas.getContext('2d');
                    canvas.width = width * (scale / 100);
                    canvas.height = height * (scale / 100);

                    // Draw the image onto the canvas
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                    // Store original image data
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    console.log('Extracted imageData:', originalImageData);
                    console.log('Image dimensions:', canvas.width, 'x', canvas.height);
                    console.log('Pixel data length:', originalImageData.data.length);

                    // Create a new image element for the dithered result
                    ditheredImage = document.querySelector('fig-image');

                    // Apply initial dithering
                    const initialColorLevels = parseInt(document.getElementById('colorLevels').value);
                    const initialBrightnessAdjust = parseInt(document.getElementById('threshold').value);
                    const initialContrastAdjust = parseInt(document.getElementById('contrast').value);
                    const initialGrayscale = document.getElementById('blackWhiteMode').checked;
                    const initialInverted = document.getElementById('invertColors').checked;
                    console.log('initialColorLevels', initialColorLevels);
                    console.log('initialBrightnessAdjust', initialBrightnessAdjust);
                    console.log('initialContrastAdjust', initialContrastAdjust);
                    console.log('initialGrayscale', initialGrayscale);
                    console.log('initialInverted', initialInverted);
                    await applyDithering(initialColorLevels, initialBrightnessAdjust, initialContrastAdjust, initialGrayscale, initialInverted);
                }
            }

            // Load initial image
            loadImageFromFigImage();

            // Debounce utility function
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            // Add event listeners
            document.addEventListener('DOMContentLoaded', () => {
                const slider = document.getElementById('colorLevels');
                const scaleSlider = document.getElementById('imageScale');
                const algorithmSelect = document.getElementById('ditheringAlgorithm');
                const blackWhiteCheckbox = document.getElementById('blackWhiteMode');
                const thresholdSlider = document.getElementById('threshold');
                const contrastSlider = document.getElementById('contrast');
                const invertColorsCheckbox = document.getElementById('invertColors');
                const figImage = document.querySelector('fig-image');

                const updateDithering = async () => {
                    const colorLevels = parseInt(slider.value);
                    const brightnessAdjust = parseInt(thresholdSlider.value);
                    const contrastAdjust = parseInt(contrastSlider.value);
                    const isGrayscale = blackWhiteCheckbox.checked;
                    const isInverted = invertColorsCheckbox.checked;
                    await applyDithering(colorLevels, brightnessAdjust, contrastAdjust, isGrayscale, isInverted);
                };

                // Create debounced versions of the update functions
                const debouncedUpdateDithering = debounce(updateDithering, 300);
                const debouncedResizeImages = debounce(resizeImages, 300);

                // Handle fig-image changes (uploads or src changes)
                if (figImage) {
                    figImage.addEventListener('loaded', (e) => {
                        console.log('fig-image changed:', e);
                        loadImageFromFigImage();
                    });
                }

                slider.addEventListener('input', (e) => {
                    console.log('slider.addEventListener', e);
                    const colorLevels = parseInt(e.detail?.value || e.target.value);
                    debouncedUpdateDithering();
                });

                scaleSlider.addEventListener('input', (e) => {
                    const scale = parseFloat(e.detail?.value || e.target.value);
                    debouncedResizeImages();
                });

                thresholdSlider.addEventListener('input', (e) => {
                    const brightnessAdjust = parseInt(e.detail?.value || e.target.value);
                    debouncedUpdateDithering();
                });

                contrastSlider.addEventListener('input', (e) => {
                    const contrastAdjust = parseInt(e.detail?.value || e.target.value);
                    debouncedUpdateDithering();
                });

                algorithmSelect.addEventListener('change', (e) => {
                    updateDithering();
                });

                blackWhiteCheckbox.addEventListener('change', (e) => {
                    console.log('blackWhiteCheckbox.addEventListener', blackWhiteCheckbox.value);
                    const thresholdGroup = document.getElementById('thresholdGroup');
                    if (blackWhiteCheckbox.checked) {
                        thresholdGroup.classList.remove('disabled');
                    } else {
                        thresholdGroup.classList.add('disabled');
                    }
                    updateDithering();
                });

                invertColorsCheckbox.addEventListener('change', (e) => {
                    updateDithering();
                });
            });

        </script>
    </main>
    <rogie-footer></rogie-footer>
</body>

</html>