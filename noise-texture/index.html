<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <meta name="description"
          content="Your website description">
    <meta name="keywords"
          content="your, keywords, here">
    <meta name="author"
          content="Your Name">
    <title>Noise & Texture Figma Plugin</title>

    <link rel="stylesheet"
          href="https://unpkg.com/@rogieking/figui3@latest/components.css" />
    <link rel="stylesheet"
          href="/rog.ie.css">
    <script src="/rog.ie.web-components.js"
            type="module"></script>
    <script src="https://unpkg.com/@rogieking/figui3@latest/fig.js"
            type="module"></script>
    <script src="/media-shader.js"></script>
    <link rel="icon"
          href="icon.png"
          type="image/png">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
    <style>
        rk-media:has(media-shader) {
            .controls {
                opacity: 0;
                position: absolute;
                bottom: 0.5rem;
                right: 0.5rem;
                left: 0.5rem;
                padding: 0rem 0.5rem;
                border-radius: 0.25rem;
                background: rgba(255, 255, 255, 1);
                box-shadow: var(--shadow);
                display: flex;
                flex-direction: row;
                gap: 0.5rem;

                fig-field:first-child {
                    padding: 0 !important;
                }

                fig-field:not(:first-child) {
                    padding: 0 0 0 0.5rem !important;
                }

                >* {
                    width: 100% !important;

                    fig-slider {
                        width: 100%;
                    }
                }

                >*:not(:first-child) {
                    border-left: 1px solid var(--figma-color-border);
                }
            }

            &:hover {
                .controls {
                    opacity: 1;
                }
            }
        }
    </style>


</head>

<body>
    <header>


        <h1><img src="icon.png"
                 class="header-icon"
                 alt="Noise & Texture">Noise & Texture</h1>
    </header>

    <main>
        <section id="about">

            <div pull="both"
                 class="rk-media plugin-header">
                <div class="media">
                    <div class="content">
                        <h1><img src="title.svg"
                                 alt="Noise & Texture" /></h1>
                        <p>Apply dynamic noise, textures, and compound effects to layers and images.</p>
                        <fig-button size="large"
                                    type="link"
                                    style="--figma-color-bg-brand: var(--accent-color);--figma-color-text-onbrand: #000;"
                                    href="https://www.figma.com/community/plugin/1138854718618193875/noise-texture">
                            <svg width="24"
                                 height="24"
                                 viewBox="0 0 24 24"
                                 fill="none"
                                 xmlns="http://www.w3.org/2000/svg">
                                <path d="M14 5.5C15.3807 5.5 16.5 6.61929 16.5 8C16.5 8.81955 16.1034 9.54407 15.4941 10C16.1034 10.4559 16.5 11.1804 16.5 12C16.5 13.3807 15.3807 14.5 14 14.5C13.4363 14.5 12.9182 14.3108 12.5 13.9961V16C12.5 17.3807 11.3807 18.5 10 18.5C8.61929 18.5 7.5 17.3807 7.5 16C7.5 15.1807 7.89593 14.456 8.50488 14C7.89593 13.544 7.5 12.8193 7.5 12C7.5 11.1807 7.89593 10.456 8.50488 10C7.89593 9.54404 7.5 8.81927 7.5 8C7.5 6.61929 8.61929 5.5 10 5.5H14ZM10 14.5C9.17157 14.5 8.5 15.1716 8.5 16C8.5 16.8284 9.17157 17.5 10 17.5C10.8284 17.5 11.5 16.8284 11.5 16V14.5H10ZM14 10.5C13.1716 10.5 12.5 11.1716 12.5 12C12.5 12.8284 13.1716 13.5 14 13.5C14.8284 13.5 15.5 12.8284 15.5 12C15.5 11.1716 14.8284 10.5 14 10.5ZM10 10.5C9.17157 10.5 8.5 11.1716 8.5 12C8.5 12.8284 9.17157 13.5 10 13.5H11.5V10.5H10ZM10 6.5C9.17157 6.5 8.5 7.17157 8.5 8C8.5 8.82843 9.17157 9.5 10 9.5H11.5V6.5H10ZM12.5 9.5H14C14.8284 9.5 15.5 8.82843 15.5 8C15.5 7.17157 14.8284 6.5 14 6.5H12.5V9.5Z"
                                      fill="black"
                                      fill-opacity="0.9" />
                            </svg>

                            <span>Install</span>
                        </fig-button>

                    </div>
                    <figure class="example">
                        <img src="ui-neuro.png" />

                    </figure>
                    <media-shader width="100%"
                                  height="350px"
                                  fragment-shader=''></media-shader>
                </div>
            </div>
            <script>
                const shader = document.querySelector('media-shader');
                const postProcessors = {
                    dither: `#version 300 es
                              precision highp float;
                uniform sampler2D u_texture;
                uniform vec2 u_resolution;
                uniform float u_time;
                uniform vec4 u_mouse;
                uniform bool u_has_texture;
                uniform float u_scale;
                uniform float u_threshold;
                in vec2 v_tex_coord;
                out vec4 glFragColor;

                float decimate(float v, float p){ return floor(v*p)/p; }
                vec2 decimate(vec2 v, float p){ return floor(v*p)/p; }
                vec2 decimate(vec2 v, vec2 p){ return floor(v*p)/p; }
                vec3 decimate(vec3 v, float p){ return floor(v*p)/p; }
                vec3 decimate(vec3 v, vec3 p){ return floor(v*p)/p; }
                vec4 decimate(vec4 v, float p){ return floor(v*p)/p; }
                vec4 decimate(vec4 v, vec4 p){ return floor(v*p)/p; }

                vec2 nearest(in vec2 v, in vec2 res) {
                    vec2 offset = 0.5 / (res - 1.0);
                    return floor(v * res) / res + offset;
                }

                vec4 sampleNearest(sampler2D tex, vec2 st, vec2 texResolution) {
                    return texture( tex, nearest(st, texResolution) );
                }

                float ditherBayer(const in vec2 xy) {
                    float x = mod(xy.x, 8.0);
                    float y = mod(xy.y, 8.0);
                    return  mix(mix(mix(mix(mix(mix(0.0,32.0,step(1.0,y)),mix(8.0,40.0,step(3.0,y)),step(2.0,y)),mix(mix(2.0,34.0,step(5.0,y)),mix(10.0,42.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(48.0,16.0,step(1.0,y)),mix(56.0,24.0,step(3.0,y)),step(2.0,y)),mix(mix(50.0,18.0,step(5.0,y)),mix(58.0,26.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(1.0,x)),mix(mix(mix(mix(12.0,44.0,step(1.0,y)),mix(4.0,36.0,step(3.0,y)),step(2.0,y)),mix(mix(14.0,46.0,step(5.0,y)),mix(6.0,38.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(60.0,28.0,step(1.0,y)),mix(52.0,20.0,step(3.0,y)),step(2.0,y)),mix(mix(62.0,30.0,step(5.0,y)),mix(54.0,22.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(3.0,x)),step(2.0,x)),mix(mix(mix(mix(mix(3.0,35.0,step(1.0,y)),mix(11.0,43.0,step(3.0,y)),step(2.0,y)),mix(mix(1.0,33.0,step(5.0,y)),mix(9.0,41.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(51.0,19.0,step(1.0,y)),mix(59.0,27.0,step(3.0,y)),step(2.0,y)),mix(mix(49.0,17.0,step(5.0,y)),mix(57.0,25.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(5.0,x)),mix(mix(mix(mix(15.0,47.0,step(1.0,y)),mix(7.0,39.0,step(3.0,y)),step(2.0,y)),mix(mix(13.0,45.0,step(5.0,y)),mix(5.0,37.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(63.0,31.0,step(1.0,y)),mix(55.0,23.0,step(3.0,y)),step(2.0,y)),mix(mix(61.0,29.0,step(5.0,y)),mix(53.0,21.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(7.0,x)),step(6.0,x)),step(4.0,x)) / (64.0);
                }

                vec3 ditherBayer(vec3 color, const in vec2 xy, const int pres) {
                    float d = float(pres);
                    vec3 decimated = decimate(color, d);
                    vec3 diff = (color - decimated) * d;
                    vec3 ditherPattern = vec3(ditherBayer(xy));
                    return decimate(color + (step(ditherPattern, diff) / d), d);
                }

                vec4 ditherBayer(const in vec4 color, const in vec2 xy, const int pres) {  
                    return vec4(ditherBayer(color.rgb, xy, pres), color.a); 
                }  

                void main() {


                    vec2 uv = v_tex_coord;

                    vec2 ditherResolution = u_resolution * (1.0 - u_scale);
                    vec4 color = sampleNearest(u_texture, uv, ditherResolution);

                    color = ditherBayer(color, uv * ditherResolution, int(mix(2.0, 8.0, u_threshold)));
                    
                    glFragColor = color;
                }
            `
                }
                let shaders = [
                    {
                        fragmentShader: `#version 300 es
                              precision highp float;
                              uniform vec2 u_resolution;
                              uniform float u_time;
                              uniform vec4 u_color;
                              uniform float u_scale; //units:%
                              uniform float u_speed; //units:%
                              out vec4 glFragColor;


                              void main() {
                                    vec2 st = gl_FragCoord.xy/u_resolution.xy;
                              float mr = min(u_resolution.x, u_resolution.y);
                              vec2 uv = (st.xy * 2.0 - 1.0) * u_resolution.xy / mr;

                              uv *= (1.0-u_scale) * 2.;

                              float d = -u_time * 0.5 * u_speed;
                              float a = 0.0;
                              for (float i = 0.0; i < 8.0; ++i) {
                                    a += cos(i - d - a * uv.x);
                              d += sin(uv.y * i + a);
  }
                              d += u_time * 0.5 * u_speed;
                              vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);
                              col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * u_color.rgb;
                              glFragColor = vec4(col, 1.0);
}`,
                        uniforms: [{
                            u_background: [0, 0, 0, 1],
                            u_color: [1, 1, 1, 1],
                            u_scale: .35,
                            u_speed: 0.6,
                            u_phase: .5,
                            u_brightness: .999,
                            u_resolution: [1024, 1024]
                        }, {
                            "u_scale": .7,
                            "u_threshold": 0.4
                        }
                        ],
                        postProcessor: [postProcessors.dither]
                    },
                    {
                        fragmentShader: `#version 300 es
    precision highp float;
    out vec4 glFragColor;
      uniform float u_time;
uniform vec2 u_resolution;
uniform vec4 u_background;
uniform vec4 u_color;
uniform float u_speed;
uniform float u_phase;
uniform float u_scale;
uniform float u_brightness;
vec2 rotate(vec2 uv, float th) {
  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
}
float neuro_shape(vec2 uv, float t) {
  vec2 sine_acc = vec2(0.);
  vec2 res = vec2(0.);
  float scale = 8.;
  for (int j = 0; j < 15; j++) {
    uv = rotate(uv, 1.);
    sine_acc = rotate(sine_acc, 1.);
    vec2 layer = uv * scale + float(j) + sine_acc - t;
    sine_acc += sin(layer);
    res += (.5 + .5 * cos(layer)) / scale;
    scale *= (1.2);
  }
  return res.x + res.y;
}
void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution.xy;
  uv -= .5;
  float scale = .75 * u_scale + 1e-4;
  uv *= (.001 * (1. - step(1. - scale, 1.) / scale));
  uv *= u_resolution;
  uv += .5;
  float t = u_time * u_speed + u_phase*10.;
  float noise = neuro_shape(uv, t);
  noise = u_brightness * pow(noise, 3.);
  noise += pow(noise, 12.);
  noise = max(.0, noise - .5);
  vec3 color = mix(u_background.rgb * u_background.a, u_color.rgb * u_color.a, noise);
  float opacity = mix(u_background.a, u_color.a, noise);
  glFragColor = vec4(color, opacity);
}`,
                        uniforms: [{
                            u_background: [0, 0, 0, 1],
                            u_color: [0, 1, 0, 1],
                            u_scale: .9,
                            u_speed: 0.6,
                            u_phase: .5,
                            u_brightness: .999,
                            u_resolution: [1024, 1024]
                        }, {
                            u_scale: .7,
                            u_threshold: 0.4
                        }
                        ],
                        postProcessor: [postProcessors.dither]
                    }
                ];

                let randomShader = shaders[1];
                shader.fragmentShader = [
                    randomShader.fragmentShader
                ].concat(randomShader.postProcessor)


                shader.uniforms = randomShader.uniforms;
            </script>
            <p>A Figma plugin to dynamically generate seamless tiled noise, textures, patterns, gradients,
                and
                more. Select a layer and
                add your noise or texture. Change the settings and see your layers updated live.
            </p>
        </section>
        <main>
            <article>
                <section>
                    <vstack pull="right">
                        <rk-media>
                            <media-shader width="100%"
                                          eager="true"
                                          style="aspect-ratio: 1.5/1;"
                                          fragment-shader='#version 300 es
                                                precision highp float;
                                                out vec4 glFragColor;
                                                uniform vec2 u_resolution;
                                                uniform vec3 u_color;
                                                uniform bool u_tone[3]; 
                                                uniform float u_size; 
                                                uniform bool u_fade[3]; 
                                                uniform vec2 u_fade_start;
                                                uniform vec2 u_fade_end;
                                                uniform float u_fade_amount; 
                                                uniform float u_amount; 
                                                uniform bool u_opacity_random; 
                                                uniform bool u_shape[7];
                                                uniform sampler2D u_shape_image;  
                                                uniform vec2 u_shape_image_resolution; 
                                                uniform float u_random_seed; 
                                                uniform float u_aa_passes; 
                                                float aspectScale(inout vec2 st,float xRes, float yRes){
                                                    float aspect = xRes/yRes;
                                                    float diff = (1.0 - aspect)/2.0;
                                                    float vis = 1.0;
                                                    if(aspect > 1.){
                                                    st.y *= aspect;
                                                    st.y += diff;
                                                    vis = (1.0 - step(1.0,st.y)) * (step(0.0,st.y)) * (1.0 - step(1.0,st.x)) * (step(0.0,st.x));
                                                    } else {
                                                        st.x *= yRes/xRes;
                                                        st.x += (1.0 - yRes/xRes)/2.0;
                                                        vis = (1.0 - step(1.0,st.x)) *(step(0.0,st.x)) * (1.0 - step(1.0,st.y)) *(step(0.0,st.y));
                                                    }
                                                    return vis;
                                                }
                                                highp float rand(vec2 co)
                                                {
                                                    highp float a = 12.9898;
                                                    highp float b = 78.233;
                                                    highp float c = 43758.5453;
                                                    highp float dt= dot(co.xy ,vec2(a,b));
                                                    highp float sn= mod(dt,3.14);
                                                    return fract(sin(sn) * c);
                                                }
                                                #ifndef PI
                                                #define PI 3.1415926535897932384626433832795
                                                #endif
                                            #ifndef FNC_AASTEP
                                            #define FNC_AASTEP
                                            #if defined(GL_OES_standard_derivatives)
                                            #extension GL_OES_standard_derivatives : enable
                                            #endif
                                            float aastep(float threshold, float value) {
                                            #if !defined(GL_ES) || __VERSION__ >= 300 || defined(GL_OES_standard_derivatives)
                                                float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));
                                                return smoothstep(threshold-afwidth, threshold+afwidth, value);
                                            #elif defined(AA_EDGE)
                                                float afwidth = AA_EDGE;
                                                return smoothstep(threshold-afwidth, threshold+afwidth, value);
                                            #else 
                                                return step(threshold, value);
                                            #endif
                                            }
                                            #endif
                                            #ifndef FNC_FILL
                                            #define FNC_FILL
                                            float fill(float x, float size, float edge) {
                                                return 1.0 - smoothstep(size - edge, size + edge, x);
                                            }
                                            float fill(float x, float size) {
                                                return 1.0 - aastep(size, x);
                                            }
                                            #endif
                                            #ifndef FNC_TRISDF
                                            #define FNC_TRISDF
                                            float triSDF(in vec2 st) {
                                            #ifdef CENTER_2D
                                                st -= CENTER_2D;
                                                st *= 5.0;
                                            #else
                                                st -= 0.5;
                                                st *= 5.0;
                                            #endif
                                                return max(abs(st.x) * .866025 + st.y * .5, -st.y * 0.5);
                                            }
                                            #endif
                                            #ifndef FNC_HEXSDF
                                            #define FNC_HEXSDF
                                            float hexSDF(in vec2 st) {
                                            #ifdef CENTER_2D
                                                st -= CENTER_2D;
                                                st *= 2.0;
                                            #else
                                                st = st * 2.0 - 1.0;
                                            #endif
                                                st = abs(st);
                                                return max(abs(st.y), st.x * .866025 + st.y * .5);
                                            }
                                            #endif
                                            #ifndef QTR_PI
                                            #define QTR_PI 0.78539816339
                                            #endif
                                            #ifndef HALF_PI
                                            #define HALF_PI 1.5707963267948966192313216916398
                                            #endif
                                            #ifndef PI
                                            #define PI 3.1415926535897932384626433832795
                                            #endif
                                            #ifndef TWO_PI
                                            #define TWO_PI 6.2831853071795864769252867665590
                                            #endif
                                            #ifndef TAU
                                            #define TAU 6.2831853071795864769252867665590
                                            #endif
                                            #ifndef INV_PI
                                            #define INV_PI 0.31830988618379067153776752674503
                                            #endif
                                            #ifndef INV_SQRT_TAU
                                            #define INV_SQRT_TAU 0.39894228040143267793994605993439  
                                            #endif
                                            #ifndef SQRT_HALF_PI
                                            #define SQRT_HALF_PI 1.25331413732
                                            #endif
                                            #ifndef PHI
                                            #define PHI 1.618033988749894848204586834
                                            #endif
                                            #ifndef EPSILON
                                            #define EPSILON 0.0000001
                                            #endif
                                            #ifndef GOLDEN_RATIO
                                            #define GOLDEN_RATIO 1.6180339887
                                            #endif
                                            #ifndef GOLDEN_RATIO_CONJUGATE 
                                            #define GOLDEN_RATIO_CONJUGATE 0.61803398875
                                            #endif
                                            #ifndef GOLDEN_ANGLE 
                                            #define GOLDEN_ANGLE 2.39996323
                                            #endif
                                            #ifndef FNC_SCALE
                                            #define FNC_SCALE
                                            vec2 scale(in float st, in float s, in vec2 center) { return (st - center) * s + center; }
                                            vec2 scale(in float st, in float s) {
                                            #ifdef CENTER_2D
                                                return scale(st,  s, CENTER_2D);
                                            #else
                                                return scale(st,  s, vec2(0.5));
                                            #endif
                                            }
                                            vec2 scale(in vec2 st, in vec2 s, in vec2 center) { return (st - center) * s + center; }
                                            vec2 scale(in vec2 st, in float s, in vec2 center) { return scale(st, vec2(s), center); }
                                            vec2 scale(in vec2 st, in vec2 s) {
                                            #ifdef CENTER_2D
                                                return (st - CENTER_2D) * s + CENTER_2D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec2 scale(in vec2 st, in float s) {
                                            #ifdef CENTER_2D
                                                return (st - CENTER_2D) * s + CENTER_2D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec3 scale(in vec3 st, in vec3 s, in vec3 center) { return (st - center) * s + center; }
                                            vec3 scale(in vec3 st, in float s, in vec3 center) { return (st - center) * s + center; }
                                            vec3 scale(in vec3 st, in vec3 s) {
                                            #ifdef CENTER_3D
                                                return (st - CENTER_3D) * s + CENTER_3D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec3 scale(in vec3 st, in float s) {
                                            #ifdef CENTER_3D
                                                return (st - CENTER_3D) * s + CENTER_3D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec4 scale(in vec4 st, float s) { return vec4(scale(st.xy, s), st.zw); }
                                            vec4 scale(in vec4 st, vec2 s) { return vec4(scale(st.xy, s), st.zw); }
                                            #endif
                                            #ifndef FNC_STARSDF
                                            #define FNC_STARSDF
                                            float starSDF(in vec2 st, in int V, in float s) {
                                            #ifdef CENTER_2D
                                                st -= CENTER_2D;
                                            #else
                                                st -= 0.5;
                                            #endif
                                                st *= 2.0;
                                                float a = atan(st.y, st.x) / TAU;
                                                float seg = a * float(V);
                                                a = ((floor(seg) + 0.5) / float(V) +
                                                    mix(s, -s, step(0.5, fract(seg))))
                                                    * TAU;
                                                return abs(dot(vec2(cos(a), sin(a)),
                                                                st));
                                            }
                                            float starSDF(in vec2 st, in int V) {
                                                return starSDF( scale(st, 12.0/float(V)), V, 0.1);
                                            }
                                            #endif
                                            #ifndef FNC_RECTSDF
                                            #define FNC_RECTSDF
                                            float rectSDF(vec2 p, vec2 b, float r) {
                                                vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);
                                                return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   
                                            }
                                            float rectSDF(vec2 p, float b, float r) {
                                                return rectSDF(p, vec2(b), r);
                                            }
                                            float rectSDF(in vec2 st, in vec2 s) {
                                                #ifdef CENTER_2D
                                                    st -= CENTER_2D;
                                                    st *= 2.0;
                                                #else
                                                    st = st * 2.0 - 1.0;
                                                #endif
                                                return max( abs(st.x / s.x),
                                                            abs(st.y / s.y) );
                                            }
                                            float rectSDF(in vec2 st, in float s) {
                                                return rectSDF(st, vec2(s) );
                                            }
                                            float rectSDF(in vec2 st) {
                                                return rectSDF(st, vec2(1.0));
                                            }
                                            #endif
                                            #ifndef QTR_PI
                                            #define QTR_PI 0.78539816339
                                            #endif
                                            #ifndef HALF_PI
                                            #define HALF_PI 1.5707963267948966192313216916398
                                            #endif
                                            #ifndef PI
                                            #define PI 3.1415926535897932384626433832795
                                            #endif
                                            #ifndef TWO_PI
                                            #define TWO_PI 6.2831853071795864769252867665590
                                            #endif
                                            #ifndef TAU
                                            #define TAU 6.2831853071795864769252867665590
                                            #endif
                                            #ifndef INV_PI
                                            #define INV_PI 0.31830988618379067153776752674503
                                            #endif
                                            #ifndef INV_SQRT_TAU
                                            #define INV_SQRT_TAU 0.39894228040143267793994605993439  
                                            #endif
                                            #ifndef SQRT_HALF_PI
                                            #define SQRT_HALF_PI 1.25331413732
                                            #endif
                                            #ifndef PHI
                                            #define PHI 1.618033988749894848204586834
                                            #endif
                                            #ifndef EPSILON
                                            #define EPSILON 0.0000001
                                            #endif
                                            #ifndef GOLDEN_RATIO
                                            #define GOLDEN_RATIO 1.6180339887
                                            #endif
                                            #ifndef GOLDEN_RATIO_CONJUGATE 
                                            #define GOLDEN_RATIO_CONJUGATE 0.61803398875
                                            #endif
                                            #ifndef GOLDEN_ANGLE 
                                            #define GOLDEN_ANGLE 2.39996323
                                            #endif
                                            #ifndef FNC_SCALE
                                            #define FNC_SCALE
                                            vec2 scale(in float st, in float s, in vec2 center) { return (st - center) * s + center; }
                                            vec2 scale(in float st, in float s) {
                                            #ifdef CENTER_2D
                                                return scale(st,  s, CENTER_2D);
                                            #else
                                                return scale(st,  s, vec2(0.5));
                                            #endif
                                            }
                                            vec2 scale(in vec2 st, in vec2 s, in vec2 center) { return (st - center) * s + center; }
                                            vec2 scale(in vec2 st, in float s, in vec2 center) { return scale(st, vec2(s), center); }
                                            vec2 scale(in vec2 st, in vec2 s) {
                                            #ifdef CENTER_2D
                                                return (st - CENTER_2D) * s + CENTER_2D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec2 scale(in vec2 st, in float s) {
                                            #ifdef CENTER_2D
                                                return (st - CENTER_2D) * s + CENTER_2D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec3 scale(in vec3 st, in vec3 s, in vec3 center) { return (st - center) * s + center; }
                                            vec3 scale(in vec3 st, in float s, in vec3 center) { return (st - center) * s + center; }
                                            vec3 scale(in vec3 st, in vec3 s) {
                                            #ifdef CENTER_3D
                                                return (st - CENTER_3D) * s + CENTER_3D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec3 scale(in vec3 st, in float s) {
                                            #ifdef CENTER_3D
                                                return (st - CENTER_3D) * s + CENTER_3D;
                                            #else
                                                return (st - 0.5) * s + 0.5;
                                            #endif
                                            }
                                            vec4 scale(in vec4 st, float s) { return vec4(scale(st.xy, s), st.zw); }
                                            vec4 scale(in vec4 st, vec2 s) { return vec4(scale(st.xy, s), st.zw); }
                                            #endif
                                            #ifndef FNC_STARSDF
                                            #define FNC_STARSDF
                                            float starSDF(in vec2 st, in int V, in float s) {
                                            #ifdef CENTER_2D
                                                st -= CENTER_2D;
                                            #else
                                                st -= 0.5;
                                            #endif
                                                st *= 2.0;
                                                float a = atan(st.y, st.x) / TAU;
                                                float seg = a * float(V);
                                                a = ((floor(seg) + 0.5) / float(V) +
                                                    mix(s, -s, step(0.5, fract(seg))))
                                                    * TAU;
                                                return abs(dot(vec2(cos(a), sin(a)),
                                                                st));
                                            }
                                            float starSDF(in vec2 st, in int V) {
                                                return starSDF( scale(st, 12.0/float(V)), V, 0.1);
                                            }
                                            #endif
                                            #ifndef CIRCLESDF_FNC
                                            #define CIRCLESDF_FNC(POS_UV) length(POS_UV)
                                            #endif
                                            #ifndef FNC_CIRCLESDF
                                            #define FNC_CIRCLESDF
                                            float circleSDF(in vec2 v) {
                                            #ifdef CENTER_2D
                                                v -= CENTER_2D;
                                            #else
                                                v -= 0.5;
                                            #endif
                                                return CIRCLESDF_FNC(v) * 2.0;
                                            }
                                            #endif
                                            #if !defined(FNC_SATURATE) && !defined(saturate)
                                            #define FNC_SATURATE
                                            #define saturate(V) clamp(V, 0.0, 1.0)
                                            #endif
                                            #ifndef FNC_LINESDF
                                            #define FNC_LINESDF
                                            float lineSDF( in vec2 st, in vec2 a, in vec2 b ) {
                                                vec2 b_to_a = b - a;
                                                vec2 to_a = st - a;
                                                float h = saturate(dot(to_a, b_to_a)/dot(b_to_a, b_to_a));
                                                return length(to_a - h * b_to_a );
                                            }
                                            float lineSDF(vec3 p, vec3 a, vec3 b) {
                                                return length(cross(p - a, p - b))/length(b - a);
                                            }
                                            #endif
                                            #ifndef FNC_RECTSDF
                                            #define FNC_RECTSDF
                                            float rectSDF(vec2 p, vec2 b, float r) {
                                                vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);
                                                return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   
                                            }
                                            float rectSDF(vec2 p, float b, float r) {
                                                return rectSDF(p, vec2(b), r);
                                            }
                                            float rectSDF(in vec2 st, in vec2 s) {
                                                #ifdef CENTER_2D
                                                    st -= CENTER_2D;
                                                    st *= 2.0;
                                                #else
                                                    st = st * 2.0 - 1.0;
                                                #endif
                                                return max( abs(st.x / s.x),
                                                            abs(st.y / s.y) );
                                            }
                                            float rectSDF(in vec2 st, in float s) {
                                                return rectSDF(st, vec2(s) );
                                            }
                                            float rectSDF(in vec2 st) {
                                                return rectSDF(st, vec2(1.0));
                                            }
                                            #endif
                                            #ifndef FNC_CROSSSDF
                                            #define FNC_CROSSSDF
                                            float crossSDF(in vec2 st, in float s) {
                                                vec2 size = vec2(.25, s);
                                                return min(rectSDF(st.xy, size.xy),
                                                            rectSDF(st.xy, size.yx));
                                            }
                                            #endif
                                            #ifndef FNC_ROTATE2D
                                            #define FNC_ROTATE2D
                                            mat2 rotate2d(in float r){
                                                float c = cos(r);
                                                float s = sin(r);
                                                return mat2(c, -s, s, c);
                                            }
                                            #endif
                                            #ifndef FNC_ROTATE4D
                                            #define FNC_ROTATE4D
                                            mat4 rotate4d(in vec3 a, in float r) {
                                                a = normalize(a);
                                                float s = sin(r);
                                                float c = cos(r);
                                                float oc = 1.0 - c;
                                                return mat4(oc * a.x * a.x + c,           oc * a.x * a.y - a.z * s,  oc * a.z * a.x + a.y * s,  0.0,
                                                            oc * a.x * a.y + a.z * s,  oc * a.y * a.y + c,           oc * a.y * a.z - a.x * s,  0.0,
                                                            oc * a.z * a.x - a.y * s,  oc * a.y * a.z + a.x * s,  oc * a.z * a.z + c,           0.0,
                                                            0.0,                                0.0,                                0.0,                                1.0);
                                            }
                                            #endif
                                            #ifndef FNC_ROTATE
                                            #define FNC_ROTATE
                                            vec2 rotate(in vec2 v, in float r, in vec2 c) {
                                                return rotate2d(r) * (v - c) + c;
                                            }
                                            vec2 rotate(in vec2 v, in float r) {
                                                #ifdef CENTER_2D
                                                return rotate(v, r, CENTER_2D);
                                                #else
                                                return rotate(v, r, vec2(.5));
                                                #endif
                                            }
                                            vec2 rotate(vec2 v, vec2 x_axis) {
                                                #ifdef CENTER_2D
                                                v -= CENTER_2D;
                                                #endif
                                                vec2 rta = vec2( dot(v, vec2(-x_axis.y, x_axis.x)), dot(v, x_axis) );
                                                #ifdef CENTER_2D
                                                rta += CENTER_2D;
                                                #endif
                                                return rta;
                                            }
                                            vec3 rotate(in vec3 v, in float r, in vec3 axis, in vec3 c) {
                                                return (rotate4d(axis, r) * vec4(v - c, 1.)).xyz + c;
                                            }
                                            vec3 rotate(in vec3 v, in float r, in vec3 axis) {
                                                #ifdef CENTER_3D
                                                return rotate(v, r, axis, CENTER_3D);
                                                #else
                                                return rotate(v, r, axis, vec3(0.));
                                                #endif
                                            }
                                            vec4 rotate(in vec4 v, in float r, in vec3 axis, in vec4 c) {
                                                return rotate4d(axis, r) * (v - c) + c;
                                            }
                                            vec4 rotate(in vec4 v, in float r, in vec3 axis) {
                                                #ifdef CENTER_4D
                                                return rotate(v, r, axis, CENTER_4D);
                                                #else
                                                return rotate(v, r, axis, vec4(0.));
                                                #endif
                                            }
                                            #if defined(FNC_QUATMULT)
                                            vec3 rotate(QUAT q, vec3 v) {
                                                QUAT q_c = QUAT(-q.x, -q.y, -q.z, q.w);
                                                return quatMul(q, quatMul(vec4(v, 0), q_c)).xyz;
                                            }
                                            vec3 rotate(QUAT q, vec3 v, vec3 c) {
                                                vec3 dir = v - c;
                                                return c + rotate(q, dir);
                                            }
                                            #endif
                                            #endif
                                                vec3 hash3D(vec2 x)
                                                {
                                                    uvec3 v = uvec3(x.xyx * 65536.0) * 1664525u + 1013904223u;
                                                    v += v.yzx * v.zxy;
                                                    v ^= v >> 16u;
                                                    v.x += v.y * v.z;
                                                    v.y += v.z * v.x;
                                                    v.z += v.x * v.y;
                                                    return vec3(v) * (1.0 / float(0xffffffffu));
                                                }
                                                void staticNoise(vec3 color, float scale, float distribution, bool random_opacity){
                                                    vec2 st = gl_FragCoord.xy / u_resolution.xy;
                                                    st *= u_resolution / scale; 
                                                    vec2 ipos = floor(st);  
                                                    vec2 fpos = fract(st);  
                                                    st = fpos;
                                                    float opacity = 1.0;
                                                    if (random_opacity == true) {
                                                        opacity = rand(ipos * u_random_seed);
                                                    }
                                                    float amt = hash3D(hash3D(ipos).xy).x;
                                                    vec2 center = vec2(u_resolution / scale*0.5 - 0.5);
                                                    vec2 left = vec2(u_resolution / scale);
                                                    float fade = 1.0;
                                                    if(u_fade[0]){ 
                                                        fade = 1.0;
                                                    } else if(u_fade[1]){ 
                                                        vec2 dir = u_fade_end - u_fade_start;
                                                        vec2 pos = ipos/left - u_fade_start;
                                                        float t = dot(pos, dir) / dot(dir, dir);
                                                        fade = 1.0 - (clamp(t, 0.0, 1.0) + u_fade_amount);
                                                    }
                                                    else if(u_fade[2]){ 
                                                        float dist = distance(ipos/left, u_fade_end);
                                                        float maxDist = distance(u_fade_start, u_fade_end);
                                                        fade = 1.0 - (clamp(dist/maxDist, 0.0, 1.0) + u_fade_amount);
                                                    }
                                                    if (u_tone[2] == true){
                                                        color = hash3D(ipos);
                                                    } else if (u_tone[1] == true){
                                                        if(hash3D(ipos).r > 0.5){
                                                            color.rgb = 1.0 - color.rgb;
                                                        }
                                                    }
                                                    float shape = 1.;
                                                    if(u_shape[0]){
                                                        shape = fill(rectSDF(st,vec2(1.0)),1.0);
                                                        glFragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape * fade);
                                                    }
                                                    if(u_shape[1]){
                                                        shape = fill(circleSDF(st),1.0);
                                                        glFragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape * fade);
                                                    }
                                                    if(u_shape[2]){
                                                        shape = fill(triSDF(st),1.0);
                                                        glFragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape * fade);
                                                    }
                                                    if(u_shape[3]){
                                                        shape = fill(rectSDF(rotate(st,45. * PI/180.),vec2(0.71)),1.0);
                                                        glFragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape * fade);
                                                    }
                                                    if(u_shape[4]){
                                                        shape = fill(lineSDF(st,vec2(1.0),vec2(0.0)),(u_resolution.x / scale)*0.001);
                                                        glFragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape * fade);
                                                    }
                                                    if(u_shape[5]){
                                                        shape = fill(crossSDF(st,1.0),1.0);
                                                        glFragColor = vec4(vec3(color),step(1.0 - distribution,amt) * opacity * shape * fade);
                                                    }
                                                    if(u_shape[6]){
                                                        float vis = aspectScale(st, u_shape_image_resolution.x, u_shape_image_resolution.y);
                                                        vec4 image = vec4(1.0);
                                                        image = texture(u_shape_image, st);
                                                        image.a *= step(1.0 - distribution,amt) * vis * opacity * fade;
                                                        glFragColor = image;
                                                    }
                                                }
                                                void main() {
                                                    staticNoise(u_color, u_size, u_amount, u_opacity_random);
                                                }'
                                          uniforms='{"u_tone":[false,false,true],"u_color":[1,1,1],"u_size":0.5,"u_amount":0.75,"u_fade":[true,false,false],"u_fade_start":[0.5,0],"u_fade_end":[0.5,0.5],"u_fade_amount":0,"u_opacity_random":false,"u_random_seed":0.44737339577477253,"u_shape":[true,false,false,false,false,false,false],"u_shape_image":null,"u_aa_passes":2}'>
                            </media-shader>
                            <div class="controls">
                                <fig-slider min="0.1"
                                            max="1"
                                            name="u_amount"
                                            step="0.001"
                                            value="0.75"
                                            variant="minimal"></fig-slider>
                            </div>
                        </rk-media>
                    </vstack>
                    <h2>Noise</h2>
                    <p>Repeatable noise patterns that can be used to create subtle texture for use in UI design, art
                        and illustration work. </p>
                </section>

                <section>
                    <vstack pull="right">
                        <rk-media>
                            <media-shader width="100%"
                                          eager="true"
                                          style="aspect-ratio: 1.5/1;"
                                          fragment-shader='#version 300 es
    precision highp float;
    out vec4 glFragColor;
      uniform vec2 u_resolution;
      uniform vec2 u_mouse;
      uniform float u_time;
      uniform vec3 u_color;
      uniform float u_scale;
      uniform int u_layers; 
      uniform float u_distortion; 
      uniform float u_thickness; 
      uniform float u_slope; 
      uniform float u_jitter; 
      uniform float u_sharpness; 
#define VARIANT 1          
#if VARIANT
      float ofs = .5;          
#else
      float ofs = 0.;
#endif
float RATIO = 1.,              
      CRACK_profile = 0.1;      
vec3 hash3( uvec3 x ) 
{
#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U 
    scramble; scramble; scramble; 
    return vec3(x) / float(0xffffffffU) + 1e-30; 
}
#define hash22(p)  fract( 18.5453 * sin( p * mat2(127.1,311.7,269.5,183.3)) )
#define disp(p) ( -ofs + (1.+2.*ofs) * hash22(p) )
vec3 voronoi( vec2 u )  
{
    vec2 iu = floor(u), v;
	float m = 1e9,d;
#if VARIANT
    for( int k=0; k < 25; k++ ) {
        vec2  p = iu + vec2(k%5-2,k/5-2),
#else
    for( int k=0; k < 9; k++ ) {
        vec2  p = iu + vec2(k%3-1,k/3-1),
#endif
            o = disp(p),
      	      r = p - u + o;
		d = dot(r,r);
        if( d < m ) m = d, v = r;
    }
    return vec3( sqrt(m), v+u );
}
vec3 voronoiB( vec2 u )  
{
    vec2 iu = floor(u), C, P;
	float m = 1e9,d;
#if VARIANT
    for( int k=0; k < 25; k++ ) {
        vec2  p = iu + vec2(k%5-2,k/5-2),
#else
    for( int k=0; k < 9; k++ ) {
        vec2  p = iu + vec2(k%3-1,k/3-1),
#endif
              o = disp(p),
      	      r = p - u + o;
		d = dot(r,r);
        if( d < m ) m = d, C = p-iu, P = r;
    }
    m = 1e9;
    for( int k=0; k < 25; k++ ) {
        vec2 p = iu+C + vec2(k%5-2,k/5-2),
		     o = disp(p),
             r = p-u + o;
        if( dot(P-r,P-r)>1e-5 )
        m = min( m, .5*dot( (P+r), normalize(r-P) ) );
    }
    return vec3( m, P+u );
}
#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))
int MOD = 1;  
#define hash21(p) fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123)
float noise2(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p); f = f*f*(3.-2.*f); 
    float v= mix( mix(hash21(i+vec2(0,0)),hash21(i+vec2(1,0)),f.x),
                  mix(hash21(i+vec2(0,1)),hash21(i+vec2(1,1)),f.x), f.y);
	return   MOD==0 ? v
	       : MOD==1 ? 2.*v-1.
           : MOD==2 ? abs(2.*v-1.)
                    : 1.-abs(2.*v-1.);
}
float fbm2(vec2 p) {
    float v = 0.,  a = .5;
    mat2 R = rot(.37);
    for (int i = 0; i < 9; i++, p*=2.,a/=2.) 
        p *= R,
        v += a * noise2(p);
    return v;
}
#define noise22(p) vec2(noise2(p),noise2(p+17.7))
vec2 fbm22(vec2 p) {
    vec2 v = vec2(0);
    float a = .5;
    mat2 R = rot(.37);
    for (int i = 0; i < 6; i++, p*=2.,a/=2.) 
        p *= R,
        v += a * noise22(p);
    return v;
}
vec2 mfbm22(vec2 p) {  
    vec2 v = vec2(1);
    float a = .5;
    mat2 R = rot(.37);
    for (int i = 0; i < 6; i++, p*=2.,a/=2.) 
        p *= R,
          v += v * a * noise22(p);
    return v-1.;
}
void main(){
  vec2 U = gl_FragCoord.xy;
  vec4 O = vec4(0.);
  U *= (.5 + 1.- (u_scale*1.));
    U *= 4./u_resolution.y;
    vec2 I = floor(U/2.); 
    bool vert = mod(I.x+I.y,2.)==0.; 
    vec3 H0;
    O-=O;
    for(int i=0; i<u_layers; i++) {
        vec2 V =  U / vec2(RATIO,1),                  
             D = u_distortion * fbm22(U/u_jitter) * u_jitter;
        vec3  H = voronoiB( V + D ); if (i==0) H0=H;
        float d = H.x;                                
        d = min( 1., u_slope * pow(max(0.,d-u_thickness),u_sharpness) );
        O += vec4(1.-d) / exp2(float(i));
        U *= 1.5 * rot(.37);
    }
    glFragColor = vec4(u_color, O);
}'
                                          uniforms='{"u_color":[0,0,0],"u_scale":1,"u_layers":4,"u_distortion":1,"u_thickness":0.005,"u_slope":40,"u_jitter":0.75,"u_sharpness":0.75}'>
                            </media-shader>
                            <div class="controls">
                                <fig-slider min="1"
                                            max="10"
                                            name="u_jitter"
                                            step="0.01"
                                            value="0.75"
                                            variant="minimal"></fig-slider>
                            </div>

                        </rk-media>
                    </vstack>
                    <h2>Texture</h2>
                    <p>Bring life to your designs with programatically generated textures like wood, rock, marble and
                        more.
                    </p>
                </section>

                <section>
                    <vstack pull="right">
                        <rk-media>
                            <media-shader width="100%"
                                          eager="true"
                                          style="aspect-ratio: 1.5/1;"
                                          fragment-shader='#version 300 es
                                                precision highp float;
                                                out vec4 glFragColor;
                                            uniform vec2 u_resolution;
                                            uniform vec2 u_mouse;
                                            uniform float u_time;
                                            uniform vec3 u_color;
                                            uniform float u_scale; 
                                            uniform float u_speed; 
                                            void main() {
                                              vec2 st = gl_FragCoord.xy/u_resolution.xy;
                                              float mr = min(u_resolution.x, u_resolution.y);
                                              vec2 uv = (st.xy * 2.0 - 1.0) * u_resolution.xy / mr;
                                              uv *= (1.0-u_scale) * 2.;
                                              float d = -u_time * 0.5 * u_speed;
                                              float a = 0.0;
                                              for (float i = 0.0; i < 8.0; ++i) {
                                                a += cos(i - d - a * uv.x);
                                                d += sin(uv.y * i + a);
                                              }
                                              d += u_time * 0.5 * u_speed;
                                              vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);
                                              col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5) * u_color;
                                              glFragColor = vec4(col, 1.0);
                                            }'
                                          uniforms='{"u_color":[1,1,1],"u_scale":0.8,"u_speed":1}'>
                            </media-shader>
                            <div class="controls">
                                <fig-slider min="0"
                                            max="0.95"
                                            name="u_scale"
                                            step="0.01"
                                            value="0.80"
                                            variant="minimal"></fig-slider>
                            </div>
                        </rk-media>
                    </vstack>

                    <h2>Motion</h2>
                    <p>Choose from a variety of colorful and endlessly moving gradients, and background animations.
                        Layer on
                        effects to make
                        them your own.</p>
                    </div>
                </section>
                <section>
                    <h2>Effects</h2>
                    <rk-media>
                        <media-shader src='1999.mp4'
                                      eager="true"
                                      fragment-shader='["#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        #define PASS_0 true\n        vec4 filter_getFragColor(vec2 coord){\n            return texture(u_texture, fract(coord));\n        }\n        vec4 filter_getClampedFragColor(vec2 coord){\n            return texture(u_texture, clamp(coord, vec2(0.01), vec2(0.99)) );\n        }\n        vec4 filter_getClampedFragColor(vec2 coord, float edge){\n            return texture(u_texture, clamp(coord, vec2(edge), vec2(1.0 - edge)) );\n        }\n      uniform float u_filter_tiles; \n        vec4 filter_Tile(){\n          vec2 uv = gl_FragCoord.xy/u_resolution;\n          return filter_getFragColor(u_filter_tiles * uv);\n        }\n        void main() {\n      glFragColor = filter_Tile();\n        }","#version 300 es\n    precision highp float;\n    out vec4 glFragColor;\n        uniform sampler2D u_texture;\n        uniform vec2 u_resolution;\n        uniform float u_time;\n        #define PASS_0 true\n        vec4 filter_getFragColor(vec2 coord){\n            return texture(u_texture, fract(coord));\n        }\n        vec4 filter_getClampedFragColor(vec2 coord){\n            return texture(u_texture, clamp(coord, vec2(0.01), vec2(0.99)) );\n        }\n        vec4 filter_getClampedFragColor(vec2 coord, float edge){\n            return texture(u_texture, clamp(coord, vec2(edge), vec2(1.0 - edge)) );\n        }\n        uniform bool u_filter_dither_type[7]; \n        uniform float u_filter_dither_size; \n        uniform int u_filter_precision; \n        #define DITHER_PRECISION u_filter_precision\n        #define SAMPLER_FNC(TEX, UV) filter_getClampedFragColor(UV)\n        uniform bool u_invert;\n        uniform float u_brightness;\n        uniform float u_contrast;\n        uniform float u_saturation;\n        uniform float u_shadows;\n        uniform float u_highlights;\n        uniform float u_midtones;\n        uniform float u_luminance_threshold;\n#ifndef NEAREST_FLOOR_FNC\n#define NEAREST_FLOOR_FNC(UV) floor(UV)\n#endif\n#ifndef FNC_NEAREST\n#define FNC_NEAREST\nvec2 nearest(in vec2 v, in vec2 res) {\n    vec2 offset = 0.5 / (res - 1.0);\n    return NEAREST_FLOOR_FNC(v * res) / res + offset;\n}\n#endif\n#ifndef SAMPLER_FNC\n#if __VERSION__ >= 300\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#else\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#endif\n#endif\n#ifndef SAMPLER_TYPE\n#define SAMPLER_TYPE sampler2D\n#endif\n#ifndef FNC_SAMPLENEAREST\n#define FNC_SAMPLENEAREST\nvec4 sampleNearest(SAMPLER_TYPE tex, vec2 st, vec2 texResolution) {\n    return SAMPLER_FNC( tex, nearest(st, texResolution) );\n}\n#endif\n#ifndef FNC_DECIMATE\n#define FNC_DECIMATE\nfloat decimate(float v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, vec2 p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, float p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, vec3 p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, float p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, vec4 p){ return floor(v*p)/p; }\n#endif\n#ifndef DITHER_INTERLEAVEDGRADIENTNOISE_COORD\n#define DITHER_INTERLEAVEDGRADIENTNOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_INTERLEAVEDGRADIENTNOISE_TIME DITHER_TIME\n#endif\n#ifndef DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION 255\n#endif\n#endif\n#ifndef FNC_DITHER_INTERLEAVEDGRADIENTNOISE\n#define FNC_DITHER_INTERLEAVEDGRADIENTNOISE\nfloat ditherInterleavedGradientNoise(vec2 st) {\n    #ifdef DITHER_INTERLEAVEDGRADIENTNOISE_TIME\n    st += 1337.0*fract(DITHER_INTERLEAVEDGRADIENTNOISE_TIME);\n    #endif\n    st = floor(st);\n    return fract(52.982919 * fract(dot(vec2(0.06711, 0.00584), st))) * 2.0 - 1.0;\n}\nfloat ditherInterleavedGradientNoise(const float value, const vec2 st, const int pres) {\n    float ditherPattern = ditherInterleavedGradientNoise(st);\n    return value + ditherPattern / 255.0;\n}\nvec3 ditherInterleavedGradientNoise(const vec3 color, const vec2 st, const int pres) {\n    #ifdef DITHER_INTERLEAVEDGRADIENTNOISE_CHROMATIC \n    vec3 ditherPattern = vec3(\n            ditherInterleavedGradientNoise(st),\n            ditherInterleavedGradientNoise(st + 0.1337),\n            ditherInterleavedGradientNoise(st + 0.3141));\n    #else\n    vec3 ditherPattern = vec3(ditherInterleavedGradientNoise(st));\n    #endif\n    float d = float(pres);\n    float h = 0.5 / d;\n    return decimate(color - h + ditherPattern / d, d);\n}\nvec3 ditherInterleavedGradientNoise(const vec3 color, const vec2 xy) {  return ditherInterleavedGradientNoise(color, xy, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION); }\nvec4 ditherInterleavedGradientNoise(const vec4 color, const vec2 xy) {  return vec4(ditherInterleavedGradientNoise(color.rgb, xy, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION), color.a); }\nfloat ditherInterleavedGradientNoise(const float val, int pres) { return ditherInterleavedGradientNoise(vec3(val),DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres).r; }\nvec3 ditherInterleavedGradientNoise(const vec3 color, int pres) { return ditherInterleavedGradientNoise(color, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres); }\nvec4 ditherInterleavedGradientNoise(const vec4 color, int pres) { return vec4(ditherInterleavedGradientNoise(color.rgb, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, pres), color.a); }\nfloat ditherInterleavedGradientNoise(const float val) { return ditherInterleavedGradientNoise(vec3(val), DITHER_INTERLEAVEDGRADIENTNOISE_COORD, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION).r; }\nvec3 ditherInterleavedGradientNoise(const vec3 color) { return ditherInterleavedGradientNoise(color, DITHER_INTERLEAVEDGRADIENTNOISE_COORD, DITHER_INTERLEAVEDGRADIENTNOISE_PRECISION); }\nvec4 ditherInterleavedGradientNoise(const vec4 color) { return vec4(ditherInterleavedGradientNoise(color.rgb), color.a); }\n#endif\n#ifndef HIGHP\n#if defined(TARGET_MOBILE) && defined(GL_ES)\n#define HIGHP highp\n#else\n#define HIGHP\n#endif\n#endif\n#ifndef DITHER_VLACHOS_COORD\n#define DITHER_VLACHOS_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_VLACHOS_TIME DITHER_TIME\n#endif\n#ifndef DITHER_VLACHOS_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_VLACHOS_PRECISION DITHER_PRECISION\n#else\n#define DITHER_VLACHOS_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_VLACHOS\n#define FNC_DITHER_VLACHOS\nfloat ditherVlachos(float b, vec2 st) {\n    #ifdef DITHER_VLACHOS_TIME\n    st += 1337.0*fract(DITHER_VLACHOS_TIME);\n    #endif\n    HIGHP float noise = dot(vec2(171.0, 231.0), st);\n    noise = fract(noise / 71.0);\n    noise = (noise * 2.0) - 1.0;\n    return b + (noise / 255.0);\n}\nvec3 ditherVlachos(vec2 st) {\n    #ifdef DITHER_VLACHOS_TIME\n    st += 1337.0*fract(DITHER_VLACHOS_TIME);\n    #endif\n    HIGHP vec3 noise = vec3(dot(vec2(171.0, 231.0), st));\n    noise = fract(noise / vec3(103.0, 71.0, 97.0));\n    return noise;\n}\nvec3 ditherVlachos(const in vec3 color, const in vec2 st, const int pres) {\n    float d = float(pres);\n    vec3 ditherPattern = ditherVlachos(st);\n    return decimate(color + ditherPattern / d, d);\n}\nvec3 ditherVlachos(const in vec3 color, const in vec2 xy) {\n    return ditherVlachos(color, xy, DITHER_VLACHOS_PRECISION);\n}\nvec4 ditherVlachos(vec4 color, vec2 st) { return vec4(ditherVlachos(color.rgb, st), color.a);}\nfloat ditherVlachos(float val) { return ditherVlachos(val, DITHER_VLACHOS_COORD);}\nvec3 ditherVlachos(vec3 color) { return ditherVlachos(color, DITHER_VLACHOS_COORD);}\nvec4 ditherVlachos(vec4 color) { return vec4(ditherVlachos(color.rgb), color.a);}\n#endif\n#ifndef DITHER_TRIANGLENOISE_COORD\n#define DITHER_TRIANGLENOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_TRIANGLENOISE_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_TRIANGLENOISE_CHROMATIC\n#endif\n#ifndef DITHER_TRIANGLENOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_TRIANGLENOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_TRIANGLENOISE_PRECISION 255\n#endif\n#endif\n#ifndef FNC_DITHER_TRIANGLENOISE\n#define FNC_DITHER_TRIANGLENOISE\nfloat triangleNoise(HIGHP in vec2 st) {\n    st = floor(st);\n    #ifdef DITHER_TRIANGLENOISE_TIME\n    st += vec2(0.07 * fract(DITHER_TRIANGLENOISE_TIME));\n    #endif\n    st  = fract(st * vec2(5.3987, 5.4421));\n    st += dot(st.yx, st.xy + vec2(21.5351, 14.3137));\n    HIGHP float xy = st.x * st.y;\n    return (fract(xy * 95.4307) + fract(xy * 75.04961) - 1.0);\n}\nvec3 ditherTriangleNoise(const in vec3 color, const HIGHP in vec2 st, const int pres) {\n    #ifdef DITHER_TRIANGLENOISE_CHROMATIC \n    vec3 ditherPattern = vec3(\n            triangleNoise(st),\n            triangleNoise(st + 0.1337),\n            triangleNoise(st + 0.3141));\n    #else\n    vec3 ditherPattern = vec3(triangleNoise(st));\n    #endif\n    float d = float(pres);\n    float h = 0.5/d;\n    return decimate(color - h + ditherPattern / d, d);\n}\nfloat ditherTriangleNoise(const in float b, const HIGHP in vec2 st) { return b + triangleNoise(st) / float(DITHER_TRIANGLENOISE_PRECISION); }\nvec3 ditherTriangleNoise(const in vec3 color, const in vec2 xy) {  return ditherTriangleNoise(color, xy, DITHER_TRIANGLENOISE_PRECISION); }\nvec4 ditherTriangleNoise(const in vec4 color, const in vec2 xy) {  return vec4(ditherTriangleNoise(color.rgb, xy, DITHER_TRIANGLENOISE_PRECISION), color.a); }\nfloat ditherTriangleNoise(const in float val, int pres) { return ditherTriangleNoise(vec3(val),DITHER_TRIANGLENOISE_COORD, pres).r; }\nvec3 ditherTriangleNoise(const in vec3 color, int pres) { return ditherTriangleNoise(color, DITHER_TRIANGLENOISE_COORD, pres); }\nvec4 ditherTriangleNoise(const in vec4 color, int pres) { return vec4(ditherTriangleNoise(color.rgb, DITHER_TRIANGLENOISE_COORD, pres), color.a); }\nfloat ditherTriangleNoise(const in float val) { return ditherTriangleNoise(vec3(val), DITHER_TRIANGLENOISE_COORD, DITHER_TRIANGLENOISE_PRECISION).r; }\nvec3 ditherTriangleNoise(const in vec3 color) { return ditherTriangleNoise(color, DITHER_TRIANGLENOISE_COORD, DITHER_TRIANGLENOISE_PRECISION); }\nvec4 ditherTriangleNoise(const in vec4 color) { return vec4(ditherTriangleNoise(color.rgb), color.a); }\n#endif\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(V) clamp(V, 0.0, 1.0)\n#endif\n#ifndef DITHER_BLUENOISE_COORD\n#define DITHER_BLUENOISE_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_BLUENOISE_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_BLUENOISE_CHROMATIC\n#endif\n#ifndef DITHER_BLUENOISE_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_BLUENOISE_PRECISION DITHER_PRECISION\n#else\n#define DITHER_BLUENOISE_PRECISION 256\n#endif\n#endif\n#ifndef BLUENOISE_TEXTURE_RESOLUTION\n#define BLUENOISE_TEXTURE_RESOLUTION vec2(1024.0)\n#endif\n#ifndef DITHER_BLUENOISE\n#define DITHER_BLUENOISE\n#ifdef BLUENOISE_TEXTURE\nfloat remap_pdf_tri_unity(float v) {\n    v = v*2.0-1.0;\n    return 0.5 + 0.5 * sign(v) * (1.0 - sqrt(1.0 - abs(v)));\n}\nconst vec2 blueNoiseTexturePixel = 1.0/BLUENOISE_TEXTURE_RESOLUTION;\nfloat ditherBlueNoise(SAMPLER_TYPE tex, const in float value, vec2 st, int pres) {\n    float d = float(pres);\n    #ifdef DITHER_BLUENOISE_TIME \n    st += 1337.0*fract(DITHER_BLUENOISE_TIME);\n    #endif\n    float bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).r;\n    float bn_tri = remap_pdf_tri_unity(bn);\n    return value + (bn_tri*2.0-0.5)/d;\n}\nvec3 ditherBlueNoise(SAMPLER_TYPE tex, vec3 color, vec2 st, int pres) {\n    float d = float(pres);\n    #ifdef DITHER_BLUENOISE_TIME\n    st += 1337.0*fract(DITHER_BLUENOISE_TIME * 0.1);\n    #endif\n    #ifdef DITHER_BLUENOISE_CHROMATIC\n    vec3 bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).color;\n    vec3 bn_tri = vec3( remap_noise_tri_erp(bn.x), \n                        remap_noise_tri_erp(bn.y), \n                        remap_noise_tri_erp(bn.z) );\n    color += (bn_tri*2.0-1.5)/d;\n    #else\n    float bn = SAMPLER_FNC(tex, st * blueNoiseTexturePixel).r;\n    float bn_tri = remap_pdf_tri_unity(bn);\n    color += (bn_tri*2.0-1.5)/d;\n    #endif\n    return color;\n}\nfloat ditherBlueNoise(SAMPLER_TYPE tex, const in float b, vec2 st) { return ditherBlueNoise(tex, b, st, DITHER_BLUENOISE_PRECISION); }\nvec3 ditherBlueNoise(SAMPLER_TYPE tex, const in vec3 rgb, vec2 st) { return ditherBlueNoise(tex, rgb, st, DITHER_BLUENOISE_PRECISION);}\nvec4 ditherBlueNoise(SAMPLER_TYPE tex, const in vec4 rgba, vec2 st) { return vec4(ditherBlueNoise(tex, rgba.rgb, st), rgba.a); }\nfloat ditherBlueNoise(const in float val) { return ditherBlueNoise(BLUENOISE_TEXTURE, val, DITHER_BLUENOISE_COORD); }\nvec3 ditherBlueNoise(const in vec3 color) { return ditherBlueNoise(BLUENOISE_TEXTURE, color, DITHER_BLUENOISE_COORD); }\nvec4 ditherBlueNoise(const in vec4 color) { return ditherBlueNoise(BLUENOISE_TEXTURE, color, DITHER_BLUENOISE_COORD); }\n#else \nfloat ditherBlueNoise(vec2 p) {\n    const float SEED1 = 1.705;\n    const float size = 5.5;\n    p = floor(p);\n    vec2 p1 = p;\n    #ifdef DITHER_BLUENOISE_TIME\n    p += 1337.0*fract(DITHER_BLUENOISE_TIME * 0.1);\n    #else\n    p += 10.0;\n    #endif\n    p = floor(p/size)*size;\n    p = fract(p * 0.1) + 1.0 + p * vec2(0.0002, 0.0003);\n    float a = fract(1.0 / (0.000001 * p.x * p.y + 0.00001));\n    a = fract(1.0 / (0.000001234 * a + 0.00001));\n    float b = fract(1.0 / (0.000002 * (p.x * p.y + p.x) + 0.00001));\n    b = fract(1.0 / (0.0000235*b + 0.00001));\n    vec2 r = vec2(a, b) - 0.5;\n    p1 += r * 8.12235325;\n    return fract(p1.x * SEED1 + p1.y/(SEED1+0.15555));\n}\nvec3 ditherBlueNoise(const in vec3 color, const in vec2 xy, const int pres) {\n    float d = float(pres);\n    vec3 decimated = decimate(color, d);\n    vec3 diff = (color - decimated) * d;\n    return saturate(decimate(color + step(vec3(ditherBlueNoise(xy)), diff) / d, d));\n}\nfloat ditherBlueNoise(const in float val, const in vec2 xy, const int pres) { return ditherBlueNoise(vec3(val), xy, pres).r; }\nvec4 ditherBlueNoise(const in vec4 color, const in vec2 xy, const int pres) { return vec4(ditherBlueNoise(color.rgb, xy, pres), color.a); }\nfloat ditherBlueNoise(const in float val, const in vec2 xy) { return ditherBlueNoise(vec3(val), xy, DITHER_BLUENOISE_PRECISION).r; }\nvec3 ditherBlueNoise(const in vec3 color, const in vec2 xy) { return ditherBlueNoise(color, xy, DITHER_BLUENOISE_PRECISION); }  \nvec4 ditherBlueNoise(const in vec4 color, const in vec2 xy) {  return vec4(ditherBlueNoise(color.rgb, xy, DITHER_BLUENOISE_PRECISION), color.a); }\nfloat ditherBlueNoise(float val) { return ditherBlueNoise(val, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\nvec3 ditherBlueNoise(vec3 color) { return ditherBlueNoise(color, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\nvec4 ditherBlueNoise(vec4 color) { return ditherBlueNoise(color, DITHER_BLUENOISE_COORD, DITHER_BLUENOISE_PRECISION); }\n#endif\n#endif\n#ifndef DITHER_SHIFT_COORD\n#define DITHER_SHIFT_COORD gl_FragCoord.xy\n#endif\n#ifdef DITHER_TIME\n#define DITHER_SHIFT_TIME DITHER_TIME\n#endif\n#ifdef DITHER_CHROMATIC\n#define DITHER_SHIFT_CHROMATIC\n#endif\n#ifndef DITHER_SHIFT_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_SHIFT_PRECISION DITHER_PRECISION\n#else\n#define DITHER_SHIFT_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_SHIFT\n#define FNC_DITHER_SHIFT\nfloat ditherShift(const in float b, const in vec2 st, const int pres) {\n    float dither_bit = 8.0; \n    #ifdef DITHER_SHIFT_TIME \n    st += 1337.0*fract(DITHER_SHIFT_TIME);\n    #endif\n    float grid_position = fract( dot( st - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    dither_shift = mix(2.0 * dither_shift, -2.0 * dither_shift, grid_position); \n    return b + 0.5/255.0 + dither_shift; \n}\nvec3 ditherShift(const in vec3 color, const in vec2 st, const int pres) {\n    float dither_bit = 8.0; \n    #ifdef DITHER_SHIFT_TIME \n    st += 1337.0*fract(DITHER_SHIFT_TIME);\n    #endif\n    float grid_position = fract( dot( st - vec2(0.5,0.5) , vec2(1.0/16.0,10.0/36.0) + 0.25 ) );\n    float dither_shift = (0.25) * (1.0 / (pow(2.0,dither_bit) - 1.0));\n    #ifdef DITHER_SHIFT_CHROMATIC\n    vec3 ditherPattern = vec3(dither_shift, -dither_shift, dither_shift);\n    #else\n    vec3 ditherPattern = vec3(dither_shift);\n    #endif\n    ditherPattern = mix(2.0 * ditherPattern, -2.0 * ditherPattern, grid_position); \n    float d = float(pres);\n    float h = 0.5/d;\n    return decimate(color + h + ditherPattern, d);\n}\nfloat ditherShift(const in float value, const in vec2 xy) {  return ditherShift(value, xy, DITHER_SHIFT_PRECISION); }\nvec3 ditherShift(const in vec3 color, const in vec2 xy) {  return ditherShift(color, xy, DITHER_SHIFT_PRECISION); }\nvec4 ditherShift(const in vec4 color, const in vec2 xy) {  return vec4(ditherShift(color.rgb, xy, DITHER_SHIFT_PRECISION), color.a); }\nfloat ditherShift(const in float val, int pres) { return ditherShift(vec3(val),DITHER_SHIFT_COORD, pres).r; }\nvec3 ditherShift(const in vec3 color, int pres) { return ditherShift(color, DITHER_SHIFT_COORD, pres); }\nvec4 ditherShift(const in vec4 color, int pres) { return vec4(ditherShift(color.rgb, DITHER_SHIFT_COORD, pres), color.a); }\nfloat ditherShift(const in float val) { return ditherShift(vec3(val), DITHER_SHIFT_COORD, DITHER_SHIFT_PRECISION).r; }\nvec3 ditherShift(const in vec3 color) { return ditherShift(color, DITHER_SHIFT_COORD, DITHER_SHIFT_PRECISION); }\nvec4 ditherShift(const in vec4 color) { return vec4(ditherShift(color.rgb), color.a); }\n#endif\n#ifndef DITHER_BAKER_COORD\n#define DITHER_BAKER_COORD gl_FragCoord.xy\n#endif\n#ifndef DITHER_BAYER_PRECISION\n#ifdef DITHER_PRECISION\n#define DITHER_BAYER_PRECISION DITHER_PRECISION\n#else\n#define DITHER_BAYER_PRECISION 256\n#endif\n#endif\n#ifndef FNC_DITHER_BAYER\n#define FNC_DITHER_BAYER\n#if defined(PLATFORM_WEBGL)\nfloat ditherBayer(const in vec2 xy) {\n    float x = mod(xy.x, 8.0);\n    float y = mod(xy.y, 8.0);\n    return  mix(mix(mix(mix(mix(mix(0.0,32.0,step(1.0,y)),mix(8.0,40.0,step(3.0,y)),step(2.0,y)),mix(mix(2.0,34.0,step(5.0,y)),mix(10.0,42.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(48.0,16.0,step(1.0,y)),mix(56.0,24.0,step(3.0,y)),step(2.0,y)),mix(mix(50.0,18.0,step(5.0,y)),mix(58.0,26.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(1.0,x)),mix(mix(mix(mix(12.0,44.0,step(1.0,y)),mix(4.0,36.0,step(3.0,y)),step(2.0,y)),mix(mix(14.0,46.0,step(5.0,y)),mix(6.0,38.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(60.0,28.0,step(1.0,y)),mix(52.0,20.0,step(3.0,y)),step(2.0,y)),mix(mix(62.0,30.0,step(5.0,y)),mix(54.0,22.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(3.0,x)),step(2.0,x)),mix(mix(mix(mix(mix(3.0,35.0,step(1.0,y)),mix(11.0,43.0,step(3.0,y)),step(2.0,y)),mix(mix(1.0,33.0,step(5.0,y)),mix(9.0,41.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(51.0,19.0,step(1.0,y)),mix(59.0,27.0,step(3.0,y)),step(2.0,y)),mix(mix(49.0,17.0,step(5.0,y)),mix(57.0,25.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(5.0,x)),mix(mix(mix(mix(15.0,47.0,step(1.0,y)),mix(7.0,39.0,step(3.0,y)),step(2.0,y)),mix(mix(13.0,45.0,step(5.0,y)),mix(5.0,37.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),mix(mix(mix(63.0,31.0,step(1.0,y)),mix(55.0,23.0,step(3.0,y)),step(2.0,y)),mix(mix(61.0,29.0,step(5.0,y)),mix(53.0,21.0,step(7.0,y)),step(6.0,y)),step(4.0,y)),step(7.0,x)),step(6.0,x)),step(4.0,x)) / (64.0);\n}\n#else\nfloat ditherBayer(const in vec2 xy) {\n    float kern[64];\n    kern[ 0] = 0.000; kern[ 1] = 0.500; kern[ 2] = 0.124; kern[ 3] = 0.624; kern[ 4] = 0.028; kern[ 5] = 0.532; kern[ 6] = 0.156; kern[ 7] = 0.656; \n    kern[ 8] = 0.752; kern[ 9] = 0.248; kern[10] = 0.876; kern[11] = 0.376; kern[12] = 0.784; kern[13] = 0.280; kern[14] = 0.908; kern[15] = 0.404; \n    kern[16] = 0.188; kern[17] = 0.688; kern[18] = 0.060; kern[19] = 0.564; kern[20] = 0.216; kern[21] = 0.720; kern[22] = 0.092; kern[23] = 0.596; \n    kern[24] = 0.940; kern[25] = 0.436; kern[26] = 0.812; kern[27] = 0.312; kern[28] = 0.972; kern[29] = 0.468; kern[30] = 0.844; kern[31] = 0.344; \n    kern[32] = 0.044; kern[33] = 0.548; kern[34] = 0.172; kern[35] = 0.672; kern[36] = 0.012; kern[37] = 0.516; kern[38] = 0.140; kern[39] = 0.640; \n    kern[40] = 0.800; kern[41] = 0.296; kern[42] = 0.924; kern[43] = 0.420; kern[44] = 0.768; kern[45] = 0.264; kern[46] = 0.892; kern[47] = 0.392; \n    kern[48] = 0.232; kern[49] = 0.736; kern[50] = 0.108; kern[51] = 0.608; kern[52] = 0.200; kern[53] = 0.704; kern[54] = 0.076; kern[55] = 0.580; \n    kern[56] = 0.988; kern[57] = 0.484; kern[58] = 0.860; kern[59] = 0.360; kern[60] = 0.956; kern[61] = 0.452; kern[62] = 0.828; kern[63] = 0.328;\n    int index = int(mod(xy.x, 8.0)) + (int(mod(xy.y, 8.0)) * 8);\n    #if defined(PLATFORM_WEBGL)\n    for (int i = 0; i < 64; i++) if (i == index) return kern[i];\n    #else\n    return kern[index];\n    #endif\n}\n#endif\nvec3 ditherBayer(vec3 color, const in vec2 xy, const int pres) {\n    float d = float(pres);\n    vec3 decimated = decimate(color, d);\n    vec3 diff = (color - decimated) * d;\n    vec3 ditherPattern = vec3(ditherBayer(xy));\n    return decimate(color + (step(ditherPattern, diff) / d), d);\n}\nfloat ditherBayer(const in float val, const in vec2 xy) { return ditherBayer(vec3(val), xy, DITHER_BAYER_PRECISION).r; }\nvec3 ditherBayer(const in vec3 color, const in vec2 xy) {  return ditherBayer(color, xy, DITHER_BAYER_PRECISION); }\nvec4 ditherBayer(const in vec4 color, const in vec2 xy) {  return vec4(ditherBayer(color.rgb, xy, DITHER_BAYER_PRECISION), color.a); }\nfloat ditherBayer(const in float val, int pres) { return ditherBayer(vec3(val),DITHER_BAKER_COORD, pres).r; }\nvec3 ditherBayer(const in vec3 color, int pres) { return ditherBayer(color, DITHER_BAKER_COORD, pres); }\nvec4 ditherBayer(const in vec4 color, int pres) { return vec4(ditherBayer(color.rgb, DITHER_BAKER_COORD, pres), color.a); }\nfloat ditherBayer(const in float val) { return ditherBayer(vec3(val), DITHER_BAKER_COORD, DITHER_BAYER_PRECISION).r; }\nvec3 ditherBayer(const in vec3 color) { return ditherBayer(color, DITHER_BAKER_COORD, DITHER_BAYER_PRECISION); }\nvec4 ditherBayer(const in vec4 color) { return vec4(ditherBayer(color.rgb), color.a); }\n#endif\n#ifndef DITHER_FNC\n#ifdef TARGET_MOBILE\n#define DITHER_FNC ditherInterleavedGradientNoise\n#else\n#define DITHER_FNC ditherVlachos\n#endif\n#endif\n#ifndef FNC_DITHER\n#define FNC_DITHER\nfloat dither(float v) { return DITHER_FNC(v); }\nvec3 dither(vec3 v) { return DITHER_FNC(v); }\nvec4 dither(vec4 v) { return DITHER_FNC(v); }\n#endif\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(const in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    return v * v;\n#endif\n}\nvec3 gamma2linear(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    return v * v;\n#endif\n}\nvec4 gamma2linear(const in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n#ifndef FNC_LINEAR2GAMMA\n#define FNC_LINEAR2GAMMA\nvec3 linear2gamma(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(1.0/GAMMA));\n#else\n    return sqrt(v);\n#endif\n}\nvec4 linear2gamma(const in vec4 v) {\n    return vec4(linear2gamma(v.rgb), v.a);\n}\nfloat linear2gamma(const in float v) {\n#ifdef GAMMA\n    return pow(v, 1.0/GAMMA);\n#else\n    return sqrt(v);\n#endif\n}\n#endif\n#ifndef SAMPLEDITHER_FNC\n#define SAMPLEDITHER_FNC ditherBayer\n#endif\n#ifndef FNC_SAMPLEDITHER\n#define FNC_SAMPLEDITHER\nvec4 sampleDither(SAMPLER_TYPE tex, const in vec2 st, const in vec2 resolution) {\n    vec4 color = sampleNearest(tex, st, resolution);\n    gamma2linear(color);\n    color = SAMPLEDITHER_FNC(color, st * resolution);\n    linear2gamma(color);\n    return color;\n}\n#endif\n        vec4 filter_Dither(){\n          vec2 pixel = 1.0/u_resolution.xy;\n          vec2 st = gl_FragCoord.xy * pixel;\n          vec2 ditherResolution = u_resolution/u_filter_dither_size;\n          vec4 color = sampleNearest(u_texture, st, ditherResolution);\n          gamma2linear(color);\n          if(u_filter_dither_type[0]){\n            color = ditherBayer(color,st * ditherResolution);\n          } else if(u_filter_dither_type[1]){\n            color = ditherBlueNoise(color,st * ditherResolution);\n          } else if(u_filter_dither_type[2]){\n            color = ditherTriangleNoise(color,st * ditherResolution);\n          } else if(u_filter_dither_type[3]){\n            color = ditherInterleavedGradientNoise(color,st * ditherResolution);\n          } else if(u_filter_dither_type[4]){\n            color = ditherVlachos(color,st * ditherResolution);\n          } else if(u_filter_dither_type[5]){\n            color = ditherShift(color,st * ditherResolution);\n          }\n          linear2gamma(color);\n          return color;\n        }\n        void main() {\n      glFragColor = filter_Dither();\n        }"]'
                                      uniforms='[{"u_filter_tiles":2},{"u_filter_dither_type":[true,false,false,false,false,false],"u_filter_dither_size":2,"u_filter_precision":2}]'>
                        </media-shader>
                        <div class="controls">
                            <fig-field direction="horizontal">
                                <label>Tiles</label>
                                <fig-slider min="1"
                                            max="8"
                                            name="u_filter_tiles"
                                            step="1"
                                            value="2"
                                            variant="minimal"></fig-slider>
                            </fig-field>
                            <fig-field direction="horizontal">
                                <label>Size</label>
                                <fig-slider min="0.1"
                                            max="8"
                                            name="u_filter_dither_size"
                                            step="0.1"
                                            value="1"
                                            variant="minimal"></fig-slider>
                            </fig-field>
                        </div>
                    </rk-media>

                    <p>Add compound effects like dithering, tilt-shift blur, and more to images, videos, and shaders.
                    </p>
                </section>
            </article>
        </main>
        <section id="subscribe">
            <rogie-signup-form></rogie-signup-form>

        </section>

    </main>

    <rogie-footer></rogie-footer>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const sliders = document.querySelectorAll('.controls fig-slider');
            sliders.forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const name = slider.getAttribute('name');
                    const value = slider.value;
                    const ms = slider.closest('rk-media').querySelector('media-shader');
                    if (ms) {
                        const uniforms = ms.getAttribute('uniforms');
                        const uniformsObj = JSON.parse(uniforms);
                        if (Array.isArray(uniformsObj)) {
                            uniformsObj.forEach(o => {
                                if (o.hasOwnProperty(name)) {
                                    o[name] = Number(value);
                                }
                            })
                        } else {
                            uniformsObj[name] = Number(value);
                        }
                        ms.setAttribute('uniforms', JSON.stringify(uniformsObj));
                    }
                });
            });
        });

    </script>

</body>

</html>